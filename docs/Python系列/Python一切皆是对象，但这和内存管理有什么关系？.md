今天是**Python的第15篇**文章，我们来聊聊Python中内存管理机制，以及循环引用的问题。



## Python的内存管理机制



对于工程师而言，**内存管理机制非常重要**，是绕不过去的一环。如果你是Java工程师，面试的时候一定会问JVM。C++工程师也一定会问内存泄漏，同样我们想要深入学习Python，内存管理机制也是绕不过去的一环。



不过好在Python的内存管理机制相对来说比较简单，我们也不用特别深入其中的细节，简单做个了解即可。



Python内存管理机制的核心就是引用计数，在Python当中一切都是对象，对象通过引用来使用。



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gezrwvc60ij30hi08874u.jpg)



我们看到的是变量名，但是变量名指向了内存当中的一块对象。这种关系在Python当中称为**引用**，我们通过引用来操作对象。所以根据这点，引用计数很好理解，也就是说我们会对每一个对象进行统计所有指向它的指针的数量。如果一个对象引用计数为0，那么说明它没有任何引用指向它，也就是说它已经没有在使用了，这个时候，Python就会将这块内存收回。



简单来说引用计数原理就是这些，但我们稍微深入一点，来简单看看哪些场景会引起对象引用的变化。



引用计数的变化显然只有两种，一种是增加，一种是减少，这两种场景都只有4种情况。我们先来看下增加的情况：



1. 首先是初始化，最简单的就是我们用**赋值操作**给一个变量赋值。举个例子：

```python
n = 123
```



这就是最简单的初始化操作，虽然123在我们来看是一个常数，但是在Python底层同样被认为是一个**常数对象**。n是它的一个引用。



2. 第二种情况是引用的传递，最简单的就是我们将一个变量的值赋值给了另外一个变量。

```python
m = n
```



比如我们将n赋值给m，它的本质是我们创建了一个新的引用，指向了同样一块内存。如果我们用id操作去查看m和n的id，会发现它们的id是一样的。也就是说它们并不是存储了两份相同的值，而是指向了同一份值。**并不是有两个叫做王小二的人，而是王小二有两个不同的账号**。



3. 第三种情况是作为元素被存储进了容器当中，比如被存储进了list当中。



```python
a = [1, 2, 123]
```

虽然我们用到了一个容器，但是容器并不会拷贝一份这些对象，还是只是**存储这些对象的引用**。



4. 最后一种情况就是作为参数传给函数，在Python当中，所有的传参都是引用传递。这也是为什么，我们经常看到有人会这样写代码的原因：



```python
def test(a):
  a.append(3)
  
a = []
test(a)
print(a)
```



我们根据上面列举的这四种引用计数增加的情况，不难推导出引用减少的情况， 其实基本上是**对称的操作**。



1. 和初始化对应的操作是**销毁**，比如我们创建的对象被del操作给销毁了，那么同样引用计数会-1



```python
del n
```



2. 和赋值给其他变量名的操作相反的操作是**覆盖**，比如之前我们的n=123，也就是n这个变量指向123，现在我们将n赋值成其他值，那么123这个对象的引用计数同样会减少。

```python
n = 124
```



3. 既然元素存储在容器当中会带来引用计数，那么同样元素**从容器当中移除**也会减少引用计数。这个也很好理解，最简单的就是list调用remove方法移除一个元素：

```python
a.remove(123)
```



4. 最后一个对应的就是作用域，也就是当变量**离开了作用域**，那么它对应的内存块的引用计数同样会减少。比如我们函数调用结束，那么作为参数的这些变量对应的引用计数都会减1。



如果一个对象的引用计数减到0，也就是没有引用再指向它的时候，那么当Python进行gc的时候，这块内存就会被释放，也就是这个对象会被清除，腾出空间来。



注意一下，引用计数减到0与内存回收之间**并不是立即发生的**，而是有一段间隔的。根据Python的机制，内存回收只会在特定条件下执行。在占用内存比较小还有很多富裕的情况下，往往是不会执行内存回收的。因为Python在执行gc（garbage collection）的时候也会stop the world，也就是暂停其他所有的任务，所以这是影响性能的一件事情，只会在有必要的时候执行。



我们费这么大劲来介绍Python中的内存机制，除了向大家科普一下这一块内容之外，更重要的一点是为了引出我们开发的时候经常遇见的一种情况——**循环引用**。



## 循环引用



如果熟悉了Python的引用，来理解循环引用是非常容易的。说白了也很简单，就是你的一个变量引用我，我的一个变量引用你。



我们来写一段简单的代码，来看看循环引用：



```python
class Test:
    def __init__(self):
        pass


if __name__ == '__main__':
    a = Test()
    b = Test()
    a.t = b
    b.t = a
```



如果你打个断点来看的话，会看到a和b之间的循环引用：



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gezrwx33tbj30ho05kmxh.jpg)



这里是**无限展开**的，因为这是一个无限循环。无限循环并不会导致程序崩溃， 也不会带来太大的问题，它的问题只有一个，就是根据前面介绍的引用计数法，a和b的引用永远不可能为0。



也就是说根据引用计数的原则，**这两个变量永远不会被回收**，这显然是不合理的。虽然Python当中专门建立了机制来解决引用循环的问题，但是我们并不知道它什么时候会被触发。



这个问题在Python当中非常普遍，尤其在我们实现一些数据结构的时候。举个最简单的例子就是树中的节点，就是引用循环的。因为父节点会存储所有的孩子，往往孩子节点也会存储父节点的信息。那么这就构成了引用循环。



```python
class Node:
  def __init__(self, val, father):
    self.val = val
    self.father = father
    self.childs = []
```





## 弱引用





为了解决这个问题，Python中提供了一个叫做弱引用的概念。弱引用本质也是一种引用，但是它不会增加对象的引用计数。也就是说它不能保证它引用的对象一定不会被销毁，只要没有销毁，弱引用就可以返回预期的结果。



弱引用不用我们自己开发，这是Python当中集成的一个现成的模块**weakref**。



这个模块当中的方法很多，用法也很多，但是我们基本上用不到，一般来说最常用的就是ref方法。通过weakref库中的ref方法，可以返回对象的一个弱引用。我们还是来看个例子：



```python
import weakref


class Test:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name


if __name__ == '__main__':
    a = Test('a')
    b = Test('b')
    a.t = weakref.ref(b)
    b.t = weakref.ref(a)

    print(a.t())
```



其实还是之前的代码，只是做了一点简单的改动。一个是我们给Test加上了name这个属性，以及str方法。另一个是我们把直接赋值改成了使用weakref。



这一次我们再打断点进来看的话，就**看不到无限循环的情况**了：



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gezrww3zxqj30iz03xaa2.jpg)



ref返回的是一个获取引用对象的方法，而不是对象本身。所以我们想要获取这个对象的话，需要再把它当成函数调用一下。



当然这样很麻烦，我们还有更好的办法，就是使用**property注解**。通过property注解，我们可以把weakref封装掉，这样在使用的时候就没有感知了。



```python
import weakref


class Test:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    @property
    def node(self):
        return None if self._node is None else self._node()

    @node.setter
    def node(self, node):
        self._node = weakref.ref(node)
```



## 总结



引用和循环引用都是基于Python本身的机制，如果对这块机制不了解，很容易采坑。因为可能会出现逻辑是对的，但是有一些意想不到的bug的情况。这种时候，往往很难通过review代码或者是测试发现，这也是我们学习的瓶颈所在。很容易发现代码已经写得很熟练了，但是一些进阶的代码还是看不懂或者是写不出来，本质上就是因为缺少了对于底层的了解和认知。



循环引用的问题在我们开发代码的时候还蛮常见的，尤其是涉及到**树和图的数据结构**的时候。由于循环引用的关系，很有可能出现被删除的树仍然占用着空间，内存不足的情况发生。这个时候使用weakref就很有必要了。



今天的文章就到这里，原创不易，**扫码关注**我，获取更多精彩文章。

![IMAGE](resources/B7AE373ACC841036368D0E2FA480D876.jpg)
